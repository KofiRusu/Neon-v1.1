[{"filePath":"/Users/kofirusu/Neon-v0.2/Neon-v0.2/packages/data-model/src/client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/kofirusu/Neon-v0.2/Neon-v0.2/packages/data-model/src/client.ts","messages":[],"suppressedMessages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":5,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":5,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/kofirusu/Neon-v0.2/Neon-v0.2/packages/data-model/src/index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/kofirusu/Neon-v0.2/Neon-v0.2/packages/data-model/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/kofirusu/Neon-v0.2/Neon-v0.2/packages/data-model/src/optimized-client.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2217,2220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2217,2220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2258,2261],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2258,2261],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2571,2574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2571,2574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { OptimizedPrismaClient } from './optimized-client';\n\ndescribe('OptimizedPrismaClient', () => {\n  let client: OptimizedPrismaClient;\n\n  beforeAll(async () => {\n    client = new OptimizedPrismaClient();\n    await client.connect();\n  });\n\n  afterAll(async () => {\n    await client.disconnect();\n  });\n\n  beforeEach(() => {\n    client.clearCache();\n    client.clearMetrics();\n  });\n\n  describe('Performance Monitoring', () => {\n    it('should track query metrics', async () => {\n      // Execute a simple query\n      await client.prisma.user.findMany({ take: 1 });\n\n      const metrics = client.getQueryMetrics();\n      expect(metrics.totalQueries).toBeGreaterThan(0);\n      expect(metrics.avgDuration).toBeGreaterThanOrEqual(0);\n      expect(metrics.recentActivity).toBeDefined();\n    });\n\n    it('should track cache hit rate', async () => {\n      const testUserId = 'test-user-id';\n      \n      // First call - should execute query\n      await client.getCampaignsByUserAndStatus(testUserId);\n      \n      // Second call - should hit cache\n      await client.getCampaignsByUserAndStatus(testUserId);\n\n      const metrics = client.getQueryMetrics();\n      expect(metrics.cacheHitRate).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Caching Functionality', () => {\n    it('should cache and return cached results', async () => {\n      const testUserId = 'test-user-123';\n\n      // First call\n      const start1 = Date.now();\n      const result1 = await client.getCampaignsByUserAndStatus(testUserId);\n      const duration1 = Date.now() - start1;\n\n      // Second call should be faster (cached)\n      const start2 = Date.now();\n      const result2 = await client.getCampaignsByUserAndStatus(testUserId);\n      const duration2 = Date.now() - start2;\n\n      // Results should be identical\n      expect(result1).toEqual(result2);\n      \n      // Second call should be faster (though this might be flaky in fast systems)\n      expect(duration2).toBeLessThanOrEqual(duration1 + 10); // Allow 10ms tolerance\n    });\n\n    it('should respect cache TTL', async () => {\n      const testUserId = 'test-user-ttl';\n\n      // Mock a very short TTL by directly accessing private method via any\n      const originalTTL = (client as any).DEFAULT_CACHE_TTL;\n      (client as any).DEFAULT_CACHE_TTL = 1; // 1ms\n\n      await client.getCampaignsByUserAndStatus(testUserId);\n      \n      // Wait for cache to expire\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      await client.getCampaignsByUserAndStatus(testUserId);\n\n      // Restore original TTL\n      (client as any).DEFAULT_CACHE_TTL = originalTTL;\n\n      const metrics = client.getQueryMetrics();\n      expect(metrics.totalQueries).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Optimized Query Methods', () => {\n    it('should execute getCampaignsByUserAndStatus with proper parameters', async () => {\n      const result = await client.getCampaignsByUserAndStatus('user-123', 'ACTIVE', 10);\n      expect(Array.isArray(result)).toBe(true);\n    });\n\n    it('should execute getAgentPerformanceMetrics with date range', async () => {\n      const startDate = new Date('2024-01-01');\n      const endDate = new Date('2024-12-31');\n      \n      const result = await client.getAgentPerformanceMetrics('agent-123', startDate, endDate);\n      expect(Array.isArray(result)).toBe(true);\n    });\n\n    it('should execute getCampaignAnalytics with filters', async () => {\n      const result = await client.getCampaignAnalytics('campaign-123', 'ENGAGEMENT', 'daily', 50);\n      expect(Array.isArray(result)).toBe(true);\n    });\n\n    it('should execute getHighValueLeads with score filter', async () => {\n      const result = await client.getHighValueLeads(8.0, 25);\n      expect(Array.isArray(result)).toBe(true);\n    });\n\n    it('should execute getTrendingKeywords with platform filter', async () => {\n      const result = await client.getTrendingKeywords('INSTAGRAM', 6.0, 15);\n      expect(Array.isArray(result)).toBe(true);\n    });\n\n    it('should execute getContentByPlatformAndStatus', async () => {\n      const result = await client.getContentByPlatformAndStatus('FACEBOOK', 'PUBLISHED', 30);\n      expect(Array.isArray(result)).toBe(true);\n    });\n  });\n\n  describe('Batch Operations', () => {\n    it('should create campaign with analytics in transaction', async () => {\n      const campaignData = {\n        name: 'Test Campaign',\n        type: 'SOCIAL_MEDIA',\n        userId: 'test-user-batch'\n      };\n\n      const initialAnalytics = [\n        {\n          type: 'ENGAGEMENT',\n          data: { views: 1000 }\n        }\n      ];\n\n      const result = await client.createCampaignWithAnalytics(campaignData, initialAnalytics);\n      expect(result).toBeDefined();\n      expect(result.name).toBe('Test Campaign');\n    });\n\n    it('should create campaign without analytics', async () => {\n      const campaignData = {\n        name: 'Simple Campaign',\n        type: 'EMAIL',\n        userId: 'test-user-simple'\n      };\n\n      const result = await client.createCampaignWithAnalytics(campaignData);\n      expect(result).toBeDefined();\n      expect(result.name).toBe('Simple Campaign');\n    });\n  });\n\n  describe('Query Metrics Analysis', () => {\n    it('should identify slow queries', async () => {\n      // Execute multiple queries to generate metrics\n      await Promise.all([\n        client.getCampaignsByUserAndStatus('user-1'),\n        client.getAgentPerformanceMetrics('agent-1'),\n        client.getCampaignAnalytics('campaign-1'),\n        client.getHighValueLeads(),\n        client.getTrendingKeywords()\n      ]);\n\n      const metrics = client.getQueryMetrics();\n      \n      expect(metrics.totalQueries).toBeGreaterThan(0);\n      expect(metrics.avgDuration).toBeGreaterThanOrEqual(0);\n      expect(Array.isArray(metrics.slowQueries)).toBe(true);\n      expect(Array.isArray(metrics.recentActivity)).toBe(true);\n      expect(metrics.cacheHitRate).toBeGreaterThanOrEqual(0);\n      expect(metrics.cacheHitRate).toBeLessThanOrEqual(1);\n    });\n\n    it('should clear metrics and cache', async () => {\n      await client.getCampaignsByUserAndStatus('test-user');\n      \n      let metrics = client.getQueryMetrics();\n      expect(metrics.totalQueries).toBeGreaterThan(0);\n\n      client.clearMetrics();\n      client.clearCache();\n\n      metrics = client.getQueryMetrics();\n      expect(metrics.totalQueries).toBe(0);\n    });\n  });\n\n  describe('Connection Management', () => {\n    it('should provide access to underlying prisma client', () => {\n      const prismaClient = client.prisma;\n      expect(prismaClient).toBeDefined();\n      expect(typeof prismaClient.user.findMany).toBe('function');\n    });\n  });\n\n  describe('Index-Optimized Queries Performance', () => {\n    it('should leverage user role and creation date index', async () => {\n      const startTime = Date.now();\n      \n      // This query should use the new index on [role, createdAt]\n      await client.prisma.user.findMany({\n        where: {\n          role: 'USER'\n        },\n        orderBy: {\n          createdAt: 'desc'\n        },\n        take: 10\n      });\n\n      const duration = Date.now() - startTime;\n      expect(duration).toBeLessThan(1000); // Should be fast with index\n    });\n\n    it('should leverage campaign status and type index', async () => {\n      const startTime = Date.now();\n      \n      // This query should use the new index on [status, type]\n      await client.prisma.campaign.findMany({\n        where: {\n          status: 'ACTIVE',\n          type: 'SOCIAL_MEDIA'\n        },\n        take: 10\n      });\n\n      const duration = Date.now() - startTime;\n      expect(duration).toBeLessThan(1000); // Should be fast with index\n    });\n\n    it('should leverage agent execution performance index', async () => {\n      const startTime = Date.now();\n      \n      // This query should use the new index on [agentId, status, startedAt]\n      await client.prisma.agentExecution.findMany({\n        where: {\n          agentId: 'test-agent',\n          status: 'COMPLETED'\n        },\n        orderBy: {\n          startedAt: 'desc'\n        },\n        take: 10\n      });\n\n      const duration = Date.now() - startTime;\n      expect(duration).toBeLessThan(1000); // Should be fast with index\n    });\n  });\n\n  describe('Real-world Usage Scenarios', () => {\n    it('should handle dashboard query pattern efficiently', async () => {\n      const userId = 'dashboard-user';\n      const startTime = Date.now();\n\n      // Simulate dashboard loading multiple data sources\n      await Promise.all([\n        client.getCampaignsByUserAndStatus(userId, 'ACTIVE'),\n        client.getCampaignAnalytics('campaign-123', 'ENGAGEMENT'),\n        client.getHighValueLeads(7.0),\n        client.getTrendingKeywords('INSTAGRAM', 5.0)\n      ]);\n\n      const totalTime = Date.now() - startTime;\n      expect(totalTime).toBeLessThan(2000); // Dashboard should load in under 2 seconds\n\n      const metrics = client.getQueryMetrics();\n      expect(metrics.totalQueries).toBeGreaterThan(0);\n    });\n\n    it('should handle repeated queries with caching', async () => {\n      const userId = 'cache-user';\n\n      // First load\n      await client.getCampaignsByUserAndStatus(userId);\n      \n      // Subsequent loads should hit cache\n      await Promise.all([\n        client.getCampaignsByUserAndStatus(userId),\n        client.getCampaignsByUserAndStatus(userId),\n        client.getCampaignsByUserAndStatus(userId)\n      ]);\n\n      const metrics = client.getQueryMetrics();\n      expect(metrics.cacheHitRate).toBeGreaterThan(0.5); // At least 50% cache hit rate\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/kofirusu/Neon-v0.2/Neon-v0.2/packages/data-model/src/optimized-client.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[301,304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[301,304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1850,1853],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1850,1853],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2107,2110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2107,2110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":117,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":117,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3634,3637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3634,3637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":143,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":143,"endColumn":35},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":172,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":172,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5049,5052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5049,5052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":195,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":195,"endColumn":26},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":214,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":214,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6074,6077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6074,6077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":238,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":238,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":248,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6649,6652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6649,6652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":249,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6698,6701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6698,6701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":258,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":258,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":259,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6897,6900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6897,6900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":260,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6925,6928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6925,6928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6984,6987],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6984,6987],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from '@prisma/client';\nimport { performance } from 'perf_hooks';\n\n// Performance monitoring types\ninterface QueryMetrics {\n  operation: string;\n  model: string;\n  duration: number;\n  timestamp: Date;\n  cached: boolean;\n  recordCount?: number;\n}\n\ninterface CacheEntry {\n  data: any;\n  timestamp: number;\n  ttl: number;\n}\n\n// Enhanced Prisma client with performance monitoring and caching\nexport class OptimizedPrismaClient {\n  private client: PrismaClient;\n  private queryMetrics: QueryMetrics[] = [];\n  private queryCache = new Map<string, CacheEntry>();\n  private readonly DEFAULT_CACHE_TTL = 300000; // 5 minutes\n  private readonly MAX_METRICS_HISTORY = 1000;\n\n  constructor() {\n    this.client = new PrismaClient();\n\n    // Set up query logging and performance monitoring\n    this.setupPerformanceMonitoring();\n  }\n\n  private setupPerformanceMonitoring(): void {\n    // Performance monitoring will be enabled when Prisma is properly configured\n    // For now, we'll use manual tracking in the executeWithCache method\n  }\n\n  // Helper methods for query analysis (will be used when needed)\n  // private extractOperation(query: string): string {\n  //   const match = query.match(/^(SELECT|INSERT|UPDATE|DELETE)/i);\n  //   return match && match[1] ? match[1].toUpperCase() : 'UNKNOWN';\n  // }\n\n  // private extractModel(query: string): string {\n  //   const match = query.match(/FROM\\s+\"([^\"]+)\"/i) || query.match(/INTO\\s+\"([^\"]+)\"/i);\n  //   return match && match[1] ? match[1] : 'unknown';\n  // }\n\n  private addMetric(metric: QueryMetrics): void {\n    this.queryMetrics.push(metric);\n    \n    // Keep only recent metrics\n    if (this.queryMetrics.length > this.MAX_METRICS_HISTORY) {\n      this.queryMetrics = this.queryMetrics.slice(-this.MAX_METRICS_HISTORY);\n    }\n  }\n\n  private generateCacheKey(operation: string, args: any): string {\n    return `${operation}:${JSON.stringify(args)}`;\n  }\n\n  private isValidCacheEntry(entry: CacheEntry): boolean {\n    return Date.now() - entry.timestamp < entry.ttl;\n  }\n\n  private async executeWithCache<T>(\n    operation: string,\n    args: any,\n    executor: () => Promise<T>,\n    cacheTTL: number = this.DEFAULT_CACHE_TTL\n  ): Promise<T> {\n    const cacheKey = this.generateCacheKey(operation, args);\n    const cachedEntry = this.queryCache.get(cacheKey);\n\n    // Return cached result if valid\n    if (cachedEntry && this.isValidCacheEntry(cachedEntry)) {\n      const metric: QueryMetrics = {\n        operation,\n        model: 'cached',\n        duration: 0,\n        timestamp: new Date(),\n        cached: true\n      };\n      this.addMetric(metric);\n      return cachedEntry.data;\n    }\n\n    // Execute query and cache result\n    const startTime = performance.now();\n    const result = await executor();\n    const duration = performance.now() - startTime;\n\n    // Cache the result\n    this.queryCache.set(cacheKey, {\n      data: result,\n      timestamp: Date.now(),\n      ttl: cacheTTL\n    });\n\n    // Record metrics\n    const metric: QueryMetrics = {\n      operation,\n      model: 'executed',\n      duration,\n      timestamp: new Date(),\n      cached: false,\n      recordCount: Array.isArray(result) ? result.length : 1\n    };\n    this.addMetric(metric);\n\n    return result;\n  }\n\n  // Optimized campaign queries using new indexes\n  async getCampaignsByUserAndStatus(\n    userId: string, \n    status?: string, \n    limit: number = 50\n  ) {\n    return this.executeWithCache(\n      'getCampaignsByUserAndStatus',\n      { userId, status, limit },\n      () => this.client.campaign.findMany({\n        where: {\n          userId,\n          ...(status && { status: status as any })\n        },\n        orderBy: { createdAt: 'desc' },\n        take: limit,\n        include: {\n          analytics: {\n            take: 1,\n            orderBy: { date: 'desc' }\n          }\n        }\n      })\n    );\n  }\n\n  // Optimized agent execution queries using new indexes\n  async getAgentPerformanceMetrics(\n    agentId: string,\n    startDate?: Date,\n    endDate?: Date\n  ) {\n    return this.executeWithCache(\n      'getAgentPerformanceMetrics',\n      { agentId, startDate, endDate },\n      () => this.client.agentExecution.findMany({\n        where: {\n          agentId,\n          ...(startDate && { startedAt: { gte: startDate } }),\n          ...(endDate && { startedAt: { lte: endDate } }),\n          status: 'COMPLETED'\n        },\n        orderBy: { startedAt: 'desc' },\n        select: {\n          id: true,\n          task: true,\n          performance: true,\n          startedAt: true,\n          completedAt: true\n        }\n      }),\n      600000 // 10 minute cache for performance data\n    );\n  }\n\n  // Optimized analytics queries using new indexes\n  async getCampaignAnalytics(\n    campaignId: string,\n    type?: string,\n    period?: string,\n    limit: number = 100\n  ) {\n    return this.executeWithCache(\n      'getCampaignAnalytics',\n      { campaignId, type, period, limit },\n      () => this.client.analytics.findMany({\n        where: {\n          campaignId,\n          ...(type && { type: type as any }),\n          ...(period && { period })\n        },\n        orderBy: { date: 'desc' },\n        take: limit\n      }),\n      300000 // 5 minute cache for analytics\n    );\n  }\n\n  // Optimized lead queries using new indexes\n  async getHighValueLeads(minScore: number = 7.0, limit: number = 50) {\n    return this.executeWithCache(\n      'getHighValueLeads',\n      { minScore, limit },\n      () => this.client.lead.findMany({\n        where: {\n          score: { gte: minScore }\n        },\n        orderBy: [\n          { score: 'desc' },\n          { createdAt: 'desc' }\n        ],\n        take: limit\n      }),\n      900000 // 15 minute cache for leads\n    );\n  }\n\n  // Optimized trend queries using new indexes\n  async getTrendingKeywords(\n    platform?: string,\n    minScore: number = 5.0,\n    limit: number = 20\n  ) {\n    return this.executeWithCache(\n      'getTrendingKeywords',\n      { platform, minScore, limit },\n      () => this.client.trend.findMany({\n        where: {\n          ...(platform && { platform: platform as any }),\n          score: { gte: minScore }\n        },\n        orderBy: [\n          { score: 'desc' },\n          { detectedAt: 'desc' }\n        ],\n        take: limit\n      }),\n      180000 // 3 minute cache for trends\n    );\n  }\n\n  // Content optimization queries\n  async getContentByPlatformAndStatus(\n    platform: string,\n    status?: string,\n    limit: number = 50\n  ) {\n    return this.executeWithCache(\n      'getContentByPlatformAndStatus',\n      { platform, status, limit },\n      () => this.client.content.findMany({\n        where: {\n          platform: platform as any,\n          ...(status && { status: status as any })\n        },\n        orderBy: { createdAt: 'desc' },\n        take: limit\n      })\n    );\n  }\n\n  // Batch operations for better performance\n  async createCampaignWithAnalytics(\n    campaignData: any,\n    initialAnalytics?: any[]\n  ) {\n    return this.client.$transaction(async (tx: any) => {\n      const campaign = await tx.campaign.create({\n        data: campaignData\n      });\n\n      if (initialAnalytics && initialAnalytics.length > 0) {\n        await tx.analytics.createMany({\n          data: initialAnalytics.map(analytics => ({\n            ...analytics,\n            campaignId: campaign.id\n          }))\n        });\n      }\n\n      return campaign;\n    });\n  }\n\n  // Performance monitoring methods\n  getQueryMetrics(): {\n    totalQueries: number;\n    avgDuration: number;\n    cacheHitRate: number;\n    slowQueries: QueryMetrics[];\n    recentActivity: QueryMetrics[];\n  } {\n    const totalQueries = this.queryMetrics.length;\n    const cachedQueries = this.queryMetrics.filter(m => m.cached).length;\n    const executedQueries = this.queryMetrics.filter(m => !m.cached);\n    \n    const avgDuration = executedQueries.length > 0 \n      ? executedQueries.reduce((sum, m) => sum + m.duration, 0) / executedQueries.length\n      : 0;\n\n    const cacheHitRate = totalQueries > 0 ? cachedQueries / totalQueries : 0;\n\n    const slowQueries = executedQueries\n      .filter(m => m.duration > 100) // Queries taking more than 100ms\n      .sort((a, b) => b.duration - a.duration)\n      .slice(0, 10);\n\n    const recentActivity = this.queryMetrics\n      .slice(-20)\n      .reverse();\n\n    return {\n      totalQueries,\n      avgDuration,\n      cacheHitRate,\n      slowQueries,\n      recentActivity\n    };\n  }\n\n  clearCache(): void {\n    this.queryCache.clear();\n  }\n\n  clearMetrics(): void {\n    this.queryMetrics = [];\n  }\n\n  // Connection management\n  async connect(): Promise<void> {\n    await this.client.$connect();\n  }\n\n  async disconnect(): Promise<void> {\n    await this.client.$disconnect();\n  }\n\n  // Direct client access for advanced operations\n  get prisma(): PrismaClient {\n    return this.client;\n  }\n}\n\n// Export singleton instance\nexport const optimizedDb = new OptimizedPrismaClient();\n\n// Export types for use in applications\nexport type { QueryMetrics };","usedDeprecatedRules":[]}]
