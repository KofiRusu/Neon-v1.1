[{"filePath":"/workspace/apps/api/next-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/app/api/health/route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/app/api/health/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/app/api/trpc/[trpc]/route.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/app/api/trpc/[trpc]/route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[446,449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[446,449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[462,465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[462,465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { type NextRequest } from 'next/server';\n\nimport { appRouter } from '~/server/root';\nimport { createTRPCContext } from '~/server/trpc';\nimport { logger } from '@neon/utils';\n\nconst handler = (req: NextRequest): Promise<Response> =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => createTRPCContext({ req: req as any, res: {} as any }),\n    onError: ({ path, error }): void => {\n      if (process.env.NODE_ENV === 'development') {\n        logger.error(`‚ùå tRPC failed on ${path ?? '<no-path>'}: ${error.message}`);\n      }\n    },\n  });\n\nexport { handler as GET, handler as POST };\n","usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/routers/brand-voice.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/routers/content.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/routers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/routers/seo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/__test__/helpers/mock-context.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[135,138],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[135,138],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[151,154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[151,154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[166,169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[166,169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2345,2348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2345,2348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\n\n// Mock context type based on expected tRPC context structure\ninterface MockContext {\n  prisma: any;\n  session: any;\n  logger: any;\n}\n\nexport function createTRPCMockContext(): MockContext {\n  return {\n    prisma: {\n      user: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      agent: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      agentExecution: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      campaign: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      content: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      analytics: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n        aggregate: jest.fn(),\n        groupBy: jest.fn(),\n      },\n      lead: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      trend: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      abTest: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      designTemplate: {\n        findUnique: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n        count: jest.fn(),\n      },\n      $transaction: jest.fn(),\n      $connect: jest.fn(),\n      $disconnect: jest.fn(),\n    } as any,\n    session: null,\n    logger: {\n      info: jest.fn(),\n      error: jest.fn(),\n      warn: jest.fn(),\n      debug: jest.fn(),\n    },\n  };\n}\n\nexport function createMockUser() {\n  return {\n    id: 'user1',\n    email: 'test@example.com',\n    name: 'Test User',\n    role: 'USER',\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n}\n\nexport function createMockSession(user = createMockUser()) {\n  return {\n    user,\n    expires: new Date(Date.now() + 1000 * 60 * 60 * 24), // 24 hours\n  };\n}\n\nexport function createMockAgent() {\n  return {\n    id: 'agent1',\n    name: 'Test Agent',\n    type: 'CONTENT',\n    status: 'ACTIVE',\n    capabilities: {},\n    settings: {},\n    version: '1.0.0',\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n}\n\nexport function createMockCampaign() {\n  return {\n    id: 'campaign1',\n    name: 'Test Campaign',\n    description: 'Test campaign description',\n    type: 'SOCIAL_MEDIA',\n    status: 'ACTIVE',\n    budget: 1000,\n    startDate: new Date(),\n    endDate: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30), // 30 days\n    userId: 'user1',\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n}\n\nexport function createMockExecution() {\n  return {\n    id: 'execution1',\n    agentId: 'agent1',\n    campaignId: 'campaign1',\n    userId: 'user1',\n    task: 'test_task',\n    payload: {},\n    result: null,\n    status: 'PENDING',\n    performance: null,\n    error: null,\n    startedAt: new Date(),\n    completedAt: null,\n    metadata: {},\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/root.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/root.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/agent.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[450,453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[450,453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[479,482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[479,482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';\nimport { TRPCError } from '@trpc/server';\nimport { agentRouter } from './agent';\nimport { createTRPCMockContext } from '../__test__/helpers/mock-context';\n\n// Mock the AgentManager\njest.mock('@neonhub/core-agents', () => ({\n  AgentManager: jest.fn().mockImplementation(() => ({\n    getAgent: jest.fn(),\n  })),\n}));\n\ndescribe('agentRouter', () => {\n  let mockContext: any;\n  let mockAgentManager: any;\n\n  beforeEach(() => {\n    mockContext = createTRPCMockContext();\n    mockAgentManager = {\n      getAgent: jest.fn(),\n    };\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('getAll', () => {\n    it('should return all agents successfully', async () => {\n      const mockAgents = [\n        { id: '1', name: 'Content Agent', type: 'CONTENT', status: 'ACTIVE', createdAt: new Date() },\n        { id: '2', name: 'SEO Agent', type: 'SEO', status: 'ACTIVE', createdAt: new Date() },\n      ];\n      \n      mockContext.prisma.agent.findMany.mockResolvedValue(mockAgents);\n\n      const caller = agentRouter.createCaller(mockContext);\n      const result = await caller.getAll();\n\n      expect(result).toEqual(mockAgents);\n      expect(mockContext.prisma.agent.findMany).toHaveBeenCalledWith({\n        orderBy: { createdAt: 'desc' },\n      });\n    });\n\n    it('should handle database errors gracefully', async () => {\n      mockContext.prisma.agent.findMany.mockRejectedValue(new Error('Database error'));\n\n      const caller = agentRouter.createCaller(mockContext);\n\n      await expect(caller.getAll()).rejects.toThrow(TRPCError);\n      expect(mockContext.logger.error).toHaveBeenCalledWith('Failed to fetch agents:', expect.any(Error));\n    });\n  });\n\n  describe('getById', () => {\n    it('should return agent by id with executions', async () => {\n      const mockAgent = {\n        id: '1',\n        name: 'Content Agent',\n        type: 'CONTENT',\n        status: 'ACTIVE',\n        executions: [\n          { id: 'exec1', status: 'COMPLETED', startedAt: new Date() },\n        ],\n      };\n\n      mockContext.prisma.agent.findUnique.mockResolvedValue(mockAgent);\n\n      const caller = agentRouter.createCaller(mockContext);\n      const result = await caller.getById({ id: '1' });\n\n      expect(result).toEqual(mockAgent);\n      expect(mockContext.prisma.agent.findUnique).toHaveBeenCalledWith({\n        where: { id: '1' },\n        include: {\n          executions: {\n            orderBy: { startedAt: 'desc' },\n            take: 10,\n          },\n        },\n      });\n    });\n\n    it('should throw NOT_FOUND when agent does not exist', async () => {\n      mockContext.prisma.agent.findUnique.mockResolvedValue(null);\n\n      const caller = agentRouter.createCaller(mockContext);\n\n      await expect(caller.getById({ id: 'nonexistent' })).rejects.toThrow(\n        expect.objectContaining({\n          code: 'NOT_FOUND',\n          message: 'Agent not found',\n        })\n      );\n    });\n\n    it('should handle database errors', async () => {\n      mockContext.prisma.agent.findUnique.mockRejectedValue(new Error('Database error'));\n\n      const caller = agentRouter.createCaller(mockContext);\n\n      await expect(caller.getById({ id: '1' })).rejects.toThrow(TRPCError);\n    });\n  });\n\n  describe('execute', () => {\n    beforeEach(() => {\n      mockContext.session = { user: { id: 'user1' } };\n    });\n\n    it('should execute agent task successfully', async () => {\n      const mockExecution = {\n        id: 'exec1',\n        agentId: 'agent1',\n        userId: 'user1',\n        task: 'generate_content',\n        status: 'RUNNING',\n      };\n\n      const mockAgent = {\n        execute: jest.fn().mockResolvedValue({\n          success: true,\n          data: { content: 'Generated content' },\n          performance: 95,\n        }),\n      };\n\n      const updatedExecution = {\n        ...mockExecution,\n        status: 'COMPLETED',\n        result: { content: 'Generated content' },\n        performance: 95,\n        completedAt: new Date(),\n      };\n\n      mockContext.prisma.agentExecution.create.mockResolvedValue(mockExecution);\n      mockContext.prisma.agentExecution.update.mockResolvedValue(updatedExecution);\n      mockAgentManager.getAgent.mockReturnValue(mockAgent);\n\n      const caller = agentRouter.createCaller(mockContext);\n      const result = await caller.execute({\n        agentId: 'agent1',\n        task: 'generate_content',\n        payload: { topic: 'AI trends' },\n      });\n\n      expect(result).toEqual({\n        execution: updatedExecution,\n        result: { content: 'Generated content' },\n        success: true,\n      });\n\n      expect(mockContext.prisma.agentExecution.create).toHaveBeenCalledWith({\n        data: {\n          agentId: 'agent1',\n          campaignId: undefined,\n          userId: 'user1',\n          task: 'generate_content',\n          payload: { topic: 'AI trends' },\n          status: 'RUNNING',\n        },\n      });\n    });\n\n    it('should handle agent execution failure', async () => {\n      const mockExecution = { id: 'exec1', status: 'RUNNING' };\n      const mockAgent = {\n        execute: jest.fn().mockResolvedValue({\n          success: false,\n          error: 'Agent execution failed',\n          performance: 0,\n        }),\n      };\n\n      mockContext.prisma.agentExecution.create.mockResolvedValue(mockExecution);\n      mockContext.prisma.agentExecution.update.mockResolvedValue({\n        ...mockExecution,\n        status: 'FAILED',\n        error: 'Agent execution failed',\n      });\n      mockAgentManager.getAgent.mockReturnValue(mockAgent);\n\n      const caller = agentRouter.createCaller(mockContext);\n      const result = await caller.execute({\n        agentId: 'agent1',\n        task: 'generate_content',\n      });\n\n      expect(result.success).toBe(false);\n      expect(mockContext.prisma.agentExecution.update).toHaveBeenCalledWith({\n        where: { id: 'exec1' },\n        data: expect.objectContaining({\n          status: 'FAILED',\n          error: 'Agent execution failed',\n        }),\n      });\n    });\n\n    it('should throw NOT_FOUND when agent does not exist', async () => {\n      mockContext.prisma.agentExecution.create.mockResolvedValue({ id: 'exec1' });\n      mockAgentManager.getAgent.mockReturnValue(null);\n\n      const caller = agentRouter.createCaller(mockContext);\n\n      await expect(caller.execute({\n        agentId: 'nonexistent',\n        task: 'test',\n      })).rejects.toThrow(\n        expect.objectContaining({\n          code: 'NOT_FOUND',\n          message: 'Agent not found',\n        })\n      );\n    });\n  });\n\n  describe('getExecutions', () => {\n    beforeEach(() => {\n      mockContext.session = { user: { id: 'user1' } };\n    });\n\n    it('should return paginated executions', async () => {\n      const mockExecutions = [\n        { id: 'exec1', agentId: 'agent1', status: 'COMPLETED', agent: {}, campaign: {} },\n        { id: 'exec2', agentId: 'agent1', status: 'RUNNING', agent: {}, campaign: {} },\n      ];\n\n      mockContext.prisma.agentExecution.findMany.mockResolvedValue(mockExecutions);\n      mockContext.prisma.agentExecution.count.mockResolvedValue(50);\n\n      const caller = agentRouter.createCaller(mockContext);\n      const result = await caller.getExecutions({\n        agentId: 'agent1',\n        limit: 20,\n        offset: 0,\n      });\n\n      expect(result).toEqual({\n        executions: mockExecutions,\n        total: 50,\n        hasMore: true,\n      });\n    });\n\n    it('should filter by campaign when provided', async () => {\n      mockContext.prisma.agentExecution.findMany.mockResolvedValue([]);\n      mockContext.prisma.agentExecution.count.mockResolvedValue(0);\n\n      const caller = agentRouter.createCaller(mockContext);\n      await caller.getExecutions({\n        campaignId: 'campaign1',\n        limit: 10,\n        offset: 0,\n      });\n\n      expect(mockContext.prisma.agentExecution.findMany).toHaveBeenCalledWith({\n        where: {\n          campaignId: 'campaign1',\n          userId: 'user1',\n        },\n        include: {\n          agent: true,\n          campaign: true,\n        },\n        orderBy: { startedAt: 'desc' },\n        take: 10,\n        skip: 0,\n      });\n    });\n  });\n\n  describe('getMetrics', () => {\n    beforeEach(() => {\n      mockContext.session = { user: { id: 'user1' } };\n    });\n\n    it('should calculate agent performance metrics', async () => {\n      const mockExecutions = [\n        {\n          status: 'COMPLETED',\n          performance: 95,\n          startedAt: new Date('2024-01-01T10:00:00Z'),\n          completedAt: new Date('2024-01-01T10:05:00Z'),\n        },\n        {\n          status: 'COMPLETED',\n          performance: 85,\n          startedAt: new Date('2024-01-01T11:00:00Z'),\n          completedAt: new Date('2024-01-01T11:03:00Z'),\n        },\n        {\n          status: 'FAILED',\n          performance: null,\n          startedAt: new Date('2024-01-01T12:00:00Z'),\n          completedAt: null,\n        },\n      ];\n\n      mockContext.prisma.agentExecution.findMany.mockResolvedValue(mockExecutions);\n\n      const caller = agentRouter.createCaller(mockContext);\n      const result = await caller.getMetrics({\n        agentId: 'agent1',\n        timeRange: '30d',\n      });\n\n      expect(result).toEqual({\n        totalExecutions: 3,\n        successfulExecutions: 2,\n        failedExecutions: 1,\n        successRate: 66.66666666666666,\n        avgPerformance: 60, // (95 + 85 + 0) / 3\n        avgExecutionTime: expect.any(Number),\n      });\n    });\n\n    it('should handle empty execution history', async () => {\n      mockContext.prisma.agentExecution.findMany.mockResolvedValue([]);\n\n      const caller = agentRouter.createCaller(mockContext);\n      const result = await caller.getMetrics({\n        agentId: 'agent1',\n        timeRange: '7d',\n      });\n\n      expect(result).toEqual({\n        totalExecutions: 0,\n        successfulExecutions: 0,\n        failedExecutions: 0,\n        successRate: 0,\n        avgPerformance: 0,\n        avgExecutionTime: 0,\n      });\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/agent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1721,1724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1721,1724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from 'zod';\nimport { createTRPCRouter, publicProcedure, protectedProcedure } from '../trpc';\n\nconst agentNames = [\n  'ContentAgent',\n  'SEOAgent',\n  'EmailMarketingAgent',\n  'SocialPostingAgent',\n  'CustomerSupportAgent',\n  'AdAgent',\n  'OutreachAgent',\n  'TrendAgent',\n  'InsightAgent',\n  'DesignAgent',\n] as const;\n\nexport const agentRouter = createTRPCRouter({\n  // Get all AI event logs\n  getLogs: publicProcedure\n    .input(\n      z.object({\n        agent: z.enum(agentNames).optional(),\n        action: z.string().optional(),\n        limit: z.number().min(1).max(1000).default(100),\n        offset: z.number().min(0).default(0),\n        startDate: z.date().optional(),\n        endDate: z.date().optional(),\n      })\n    )\n    .query(async ({ ctx, input }) => {\n      const where = {\n        ...(input.agent && { agent: input.agent }),\n        ...(input.action && { action: { contains: input.action } }),\n        ...(input.startDate &&\n          input.endDate && {\n            createdAt: {\n              gte: input.startDate,\n              lte: input.endDate,\n            },\n          }),\n      };\n\n      return ctx.db.aIEventLog.findMany({\n        where,\n        orderBy: { createdAt: 'desc' },\n        skip: input.offset,\n        take: input.limit,\n      });\n    }),\n\n  // Log a new AI agent event\n  logEvent: protectedProcedure\n    .input(\n      z.object({\n        agent: z.enum(agentNames),\n        action: z.string().min(1),\n        metadata: z.record(z.unknown()).optional(),\n      })\n    )\n    .mutation(async ({ ctx, input }) => {\n      return ctx.db.aIEventLog.create({\n        data: {\n          agent: input.agent,\n          action: input.action,\n          metadata: (input.metadata || {}) as any,\n        },\n      });\n    }),\n\n  // Get agent activity summary\n  getActivitySummary: publicProcedure\n    .input(\n      z.object({\n        startDate: z.date().optional(),\n        endDate: z.date().optional(),\n        agent: z.enum(agentNames).optional(),\n      })\n    )\n    .query(async ({ ctx, input }) => {\n      const where = {\n        ...(input.agent && { agent: input.agent }),\n        ...(input.startDate &&\n          input.endDate && {\n            createdAt: {\n              gte: input.startDate,\n              lte: input.endDate,\n            },\n          }),\n      };\n\n      const [totalEvents, agentBreakdown] = await Promise.all([\n        ctx.db.aIEventLog.count({ where }),\n        ctx.db.aIEventLog.groupBy({\n          by: ['agent'],\n          where,\n          _count: {\n            id: true,\n          },\n        }),\n      ]);\n\n      return {\n        totalEvents,\n        agentBreakdown: agentBreakdown.map(item => ({\n          agent: item.agent,\n          count: item._count.id,\n        })),\n      };\n    }),\n\n  // Get recent agent actions\n  getRecentActions: publicProcedure\n    .input(\n      z.object({\n        limit: z.number().min(1).max(50).default(10),\n        agent: z.enum(agentNames).optional(),\n      })\n    )\n    .query(async ({ ctx, input }) => {\n      const where = input.agent ? { agent: input.agent } : {};\n\n      return ctx.db.aIEventLog.findMany({\n        where,\n        orderBy: { createdAt: 'desc' },\n        take: input.limit,\n        select: {\n          id: true,\n          agent: true,\n          action: true,\n          createdAt: true,\n          metadata: true,\n        },\n      });\n    }),\n\n  // Get agent performance metrics\n  getPerformanceMetrics: publicProcedure\n    .input(\n      z.object({\n        agent: z.enum(agentNames),\n        startDate: z.date().optional(),\n        endDate: z.date().optional(),\n      })\n    )\n    .query(async ({ ctx, input }) => {\n      const where = {\n        agent: input.agent,\n        ...(input.startDate &&\n          input.endDate && {\n            createdAt: {\n              gte: input.startDate,\n              lte: input.endDate,\n            },\n          }),\n      };\n\n      const [totalActions, successfulActions, actionBreakdown, recentActivity] = await Promise.all([\n        ctx.db.aIEventLog.count({ where }),\n        ctx.db.aIEventLog.count({\n          where: {\n            ...where,\n            action: { contains: 'success' },\n          },\n        }),\n        ctx.db.aIEventLog.groupBy({\n          by: ['action'],\n          where,\n          _count: {\n            id: true,\n          },\n        }),\n        ctx.db.aIEventLog.findMany({\n          where,\n          orderBy: { createdAt: 'desc' },\n          take: 10,\n          select: {\n            action: true,\n            createdAt: true,\n            metadata: true,\n          },\n        }),\n      ]);\n\n      const successRate = totalActions > 0 ? successfulActions / totalActions : 0;\n\n      return {\n        totalActions,\n        successfulActions,\n        successRate,\n        actionBreakdown: actionBreakdown.map(item => ({\n          action: item.action,\n          count: item._count.id,\n        })),\n        recentActivity,\n      };\n    }),\n\n  // Delete old logs (cleanup)\n  cleanupLogs: protectedProcedure\n    .input(\n      z.object({\n        olderThan: z.date(),\n        agent: z.enum(agentNames).optional(),\n      })\n    )\n    .mutation(async ({ ctx, input }) => {\n      const where = {\n        createdAt: { lt: input.olderThan },\n        ...(input.agent && { agent: input.agent }),\n      };\n\n      return ctx.db.aIEventLog.deleteMany({ where });\n    }),\n});\n","usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/brand-voice.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/campaign.test.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[401,404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[401,404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/campaign.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/content.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/email.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/metrics.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/outreach.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":43,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":65,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":98,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":127,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'input' is defined but never used. Allowed unused args must match /^_/u.","line":143,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":143,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":155,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":155,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":216,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":216,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Outreach Router - B2B Lead Generation & Management\n * Handles lead scraping, enrichment, and outreach campaigns\n */\n\nimport { z } from 'zod';\nimport { createTRPCRouter, publicProcedure } from '../trpc';\nimport { LeadScraper } from '@neon/utils/lead-scraper';\nimport { PDFGenerator } from '@neon/utils/pdf-generator';\n\nconst leadScraper = new LeadScraper();\nconst pdfGenerator = new PDFGenerator();\n\nexport const outreachRouter = createTRPCRouter({\n  // Scrape leads from LinkedIn\n  scrapeLeads: publicProcedure\n    .input(z.object({\n      searchQuery: z.string(),\n      maxResults: z.number().min(1).max(100).default(50),\n      platform: z.enum(['linkedin', 'directory']).default('linkedin'),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        let leads;\n        \n        if (input.platform === 'linkedin') {\n          leads = await leadScraper.scrapeLinkedIn(input.searchQuery, input.maxResults);\n        } else {\n          // Parse search query for industry and location\n          const [industry, location] = input.searchQuery.split(' in ');\n          leads = await leadScraper.scrapeBusinessDirectory(\n            industry || 'business',\n            location || 'United States'\n          );\n        }\n\n        return {\n          success: true,\n          data: leads,\n          count: leads.length,\n          searchQuery: input.searchQuery,\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: [],\n          error: 'Failed to scrape leads',\n        };\n      }\n    }),\n\n  // Enrich lead data\n  enrichLead: publicProcedure\n    .input(z.object({\n      email: z.string().email(),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        const enrichedData = await leadScraper.enrichLeadData(input.email);\n        \n        return {\n          success: true,\n          data: enrichedData,\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: null,\n          error: 'Failed to enrich lead data',\n        };\n      }\n    }),\n\n  // Generate proposal PDF\n  generateProposal: publicProcedure\n    .input(z.object({\n      clientName: z.string(),\n      clientCompany: z.string(),\n      signType: z.string(),\n      dimensions: z.string(),\n      price: z.number(),\n      deliveryTime: z.string(),\n      customFeatures: z.array(z.string()).optional(),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        const pdfBuffer = await pdfGenerator.generateProposal(input);\n        \n        // In production, save to file storage and return URL\n        const proposalId = `proposal_${Date.now()}`;\n        \n        return {\n          success: true,\n          proposalId,\n          downloadUrl: `/api/proposals/${proposalId}`,\n          size: pdfBuffer.length,\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          error: 'Failed to generate proposal',\n        };\n      }\n    }),\n\n  // Generate offer sheet\n  generateOfferSheet: publicProcedure\n    .input(z.object({\n      signType: z.string(),\n      targetMarket: z.string(),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        const pdfBuffer = await pdfGenerator.generateOfferSheet(\n          input.signType,\n          input.targetMarket\n        );\n        \n        const offerId = `offer_${Date.now()}`;\n        \n        return {\n          success: true,\n          offerId,\n          downloadUrl: `/api/offers/${offerId}`,\n          size: pdfBuffer.length,\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          error: 'Failed to generate offer sheet',\n        };\n      }\n    }),\n\n  // Send outreach email\n  sendOutreach: publicProcedure\n    .input(z.object({\n      leadId: z.string(),\n      subject: z.string(),\n      template: z.string(),\n      personalization: z.record(z.string()).optional(),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        // Mock email sending - integrate with SendGrid/Mailgun\n        const emailId = `email_${Date.now()}`;\n        \n        // In production, track email status\n        return {\n          success: true,\n          emailId,\n          status: 'sent',\n          sentAt: new Date().toISOString(),\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          error: 'Failed to send outreach email',\n        };\n      }\n    }),\n\n  // Get outreach campaign stats\n  getCampaignStats: publicProcedure\n    .input(z.object({\n      campaignId: z.string(),\n    }))\n    .query(async ({ input }) => {\n      // Mock campaign statistics\n      const stats = {\n        campaignId: input.campaignId,\n        totalLeads: 150,\n        emailsSent: 145,\n        emailsOpened: 78,\n        emailsReplied: 12,\n        leadsConverted: 5,\n        conversionRate: 0.034,\n        openRate: 0.538,\n        replyRate: 0.154,\n        lastUpdated: new Date().toISOString(),\n      };\n\n      return {\n        success: true,\n        data: stats,\n      };\n    }),\n\n  // Validate email list\n  validateEmails: publicProcedure\n    .input(z.object({\n      emails: z.array(z.string()),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        const validationResults = await Promise.all(\n          input.emails.map(async (email) => ({\n            email,\n            isValid: await leadScraper.validateEmail(email),\n          }))\n        );\n\n        const validEmails = validationResults.filter(r => r.isValid);\n        const invalidEmails = validationResults.filter(r => !r.isValid);\n\n        return {\n          success: true,\n          data: {\n            total: input.emails.length,\n            valid: validEmails.length,\n            invalid: invalidEmails.length,\n            validEmails: validEmails.map(v => v.email),\n            invalidEmails: invalidEmails.map(v => v.email),\n          },\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          error: 'Failed to validate emails',\n        };\n      }\n    }),\n}); ","usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/seo.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":276,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":276,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8584,8587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8584,8587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SEOAgent } from \"@neon/core-agents\";\nimport { z } from \"zod\";\nimport { createTRPCRouter, publicProcedure } from \"../trpc\";\nimport { logger } from \"@neon/utils\";\n\n// Input validation schemas\nconst seoContextSchema = z.object({\n  content: z.string().min(1, \"Content is required\"),\n  targetKeywords: z.array(z.string()).min(1, \"At least one target keyword is required\"),\n  contentType: z.enum(['blog', 'page', 'product', 'article']),\n  focusKeyword: z.string().optional(),\n  title: z.string().optional(),\n  description: z.string().optional(),\n  url: z.string().optional(),\n  businessContext: z.string().optional(),\n  targetAudience: z.string().optional(),\n});\n\nconst metaTagsInputSchema = z.object({\n  topic: z.string().min(1, \"Topic is required\"),\n  content: z.string().min(1, \"Content is required\"),\n  keywords: z.array(z.string()).optional(),\n  businessContext: z.string().optional(),\n  targetAudience: z.string().optional(),\n  contentType: z.enum(['blog', 'page', 'product', 'article']).optional(),\n});\n\nconst keywordRecommendationSchema = z.object({\n  topic: z.string().min(1, \"Topic is required\"),\n  businessContext: z.string().optional(),\n});\n\nconst competitorAnalysisSchema = z.object({\n  keywords: z.array(z.string()).min(1, \"At least one keyword is required\"),\n  industry: z.string().optional(),\n});\n\nconst technicalAuditSchema = z.object({\n  url: z.string().url(\"Valid URL is required\"),\n  content: z.string().min(1, \"Content is required\"),\n});\n\nexport const seoRouter = createTRPCRouter({\n  /**\n   * Comprehensive SEO optimization with AI-powered analysis\n   */\n  optimizeKeywords: publicProcedure\n    .input(seoContextSchema)\n    .mutation(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        const result = await seoAgent.optimizeKeywords(input);\n        \n        logger.info('SEO optimization completed', {\n          contentLength: input.content.length,\n          keywordCount: input.targetKeywords.length,\n          seoScore: result.data?.seoScore\n        }, 'SEORouter');\n\n        return result;\n      } catch (error) {\n        logger.error('SEO optimization failed', { error, input: { ...input, content: 'truncated' } }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Analyze content for keyword performance and SEO metrics\n   */\n  analyzeContent: publicProcedure\n    .input(z.object({\n      content: z.string().min(1, \"Content is required\"),\n      keywords: z.array(z.string()).min(1, \"At least one keyword is required\"),\n    }))\n    .query(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        const analysis = await seoAgent.analyzeContent(input.content, input.keywords);\n        \n        logger.info('Content analysis completed', {\n          contentLength: input.content.length,\n          keywordCount: input.keywords.length,\n          analysisResults: analysis.length\n        }, 'SEORouter');\n\n        return {\n          success: true,\n          data: analysis\n        };\n      } catch (error) {\n        logger.error('Content analysis failed', { error, inputLength: input.content.length }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Generate AI-powered meta tags with OpenAI integration\n   */\n  generateMetaTags: publicProcedure\n    .input(metaTagsInputSchema)\n    .mutation(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        const metaTags = await seoAgent.generateMetaTags(input);\n        \n        logger.info('Meta tags generated', {\n          topic: input.topic,\n          contentType: input.contentType,\n          hasKeywords: Boolean(input.keywords?.length),\n          titleLength: metaTags.title.length,\n          descriptionLength: metaTags.description.length\n        }, 'SEORouter');\n\n        return {\n          success: true,\n          data: metaTags\n        };\n      } catch (error) {\n        logger.error('Meta tags generation failed', { error, topic: input.topic }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Get AI-powered keyword recommendations\n   */\n  recommendKeywords: publicProcedure\n    .input(keywordRecommendationSchema)\n    .query(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        const recommendations = await seoAgent.recommendKeywords(input);\n        \n        logger.info('Keyword recommendations generated', {\n          topic: input.topic,\n          recommendationCount: recommendations.length,\n          hasBusinessContext: Boolean(input.businessContext)\n        }, 'SEORouter');\n\n        return {\n          success: true,\n          data: recommendations\n        };\n      } catch (error) {\n        logger.error('Keyword recommendations failed', { error, topic: input.topic }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Analyze competitors for SEO insights\n   */\n  analyzeCompetitors: publicProcedure\n    .input(competitorAnalysisSchema)\n    .mutation(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        const result = await seoAgent.execute({\n          task: 'analyze_competitors',\n          context: input,\n          priority: 'medium'\n        });\n        \n        logger.info('Competitor analysis completed', {\n          keywordCount: input.keywords.length,\n          industry: input.industry,\n          success: result.success\n        }, 'SEORouter');\n\n        return result;\n      } catch (error) {\n        logger.error('Competitor analysis failed', { error, keywords: input.keywords }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Generate schema markup for content\n   */\n  generateSchema: publicProcedure\n    .input(seoContextSchema)\n    .mutation(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        const result = await seoAgent.execute({\n          task: 'generate_schema',\n          context: input,\n          priority: 'medium'\n        });\n        \n        logger.info('Schema markup generated', {\n          contentType: input.contentType,\n          title: input.title,\n          success: result.success\n        }, 'SEORouter');\n\n        return result;\n      } catch (error) {\n        logger.error('Schema generation failed', { error, contentType: input.contentType }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Perform technical SEO audit\n   */\n  auditTechnicalSEO: publicProcedure\n    .input(technicalAuditSchema)\n    .mutation(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        const result = await seoAgent.execute({\n          task: 'audit_technical_seo',\n          context: input,\n          priority: 'medium'\n        });\n        \n        logger.info('Technical SEO audit completed', {\n          url: input.url,\n          contentLength: input.content.length,\n          issuesFound: result.data?.length || 0,\n          success: result.success\n        }, 'SEORouter');\n\n        return result;\n      } catch (error) {\n        logger.error('Technical SEO audit failed', { error, url: input.url }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Get comprehensive SEO analysis (combines multiple features)\n   */\n  getComprehensiveAnalysis: publicProcedure\n    .input(seoContextSchema)\n    .mutation(async ({ input }) => {\n      try {\n        const seoAgent = new SEOAgent();\n        \n        // Run multiple analyses in parallel for better performance\n        const [\n          contentAnalysis,\n          keywordRecommendations,\n          technicalAudit,\n          schemaMarkup\n        ] = await Promise.all([\n          seoAgent.execute({\n            task: 'analyze_content',\n            context: input,\n            priority: 'high'\n          }),\n          seoAgent.recommendKeywords({\n            topic: input.focusKeyword || input.targetKeywords[0],\n            businessContext: input.businessContext\n          }),\n          input.url ? seoAgent.execute({\n            task: 'audit_technical_seo',\n            context: { url: input.url, content: input.content },\n            priority: 'medium'\n          }) : Promise.resolve(null),\n          seoAgent.execute({\n            task: 'generate_schema',\n            context: input,\n            priority: 'low'\n          })\n        ]);\n\n        const comprehensiveReport = {\n          contentAnalysis: contentAnalysis.data,\n          keywordRecommendations,\n          technicalAudit: technicalAudit?.data || [],\n          schemaMarkup: schemaMarkup.data,\n          summary: {\n            overallScore: contentAnalysis.data?.seoScore || 0,\n            criticalIssues: (contentAnalysis.data?.suggestions || []).filter((s: any) => s.severity === 'critical').length,\n            recommendations: keywordRecommendations.length,\n            technicalIssues: technicalAudit?.data?.length || 0\n          }\n        };\n        \n        logger.info('Comprehensive SEO analysis completed', {\n          overallScore: comprehensiveReport.summary.overallScore,\n          criticalIssues: comprehensiveReport.summary.criticalIssues,\n          recommendations: comprehensiveReport.summary.recommendations,\n          contentType: input.contentType\n        }, 'SEORouter');\n\n        return {\n          success: true,\n          data: comprehensiveReport\n        };\n      } catch (error) {\n        logger.error('Comprehensive SEO analysis failed', { error, contentType: input.contentType }, 'SEORouter');\n        throw error;\n      }\n    }),\n\n  /**\n   * Get SEO agent status and capabilities\n   */\n  getAgentStatus: publicProcedure\n    .query(async () => {\n      try {\n        const seoAgent = new SEOAgent();\n        const status = await seoAgent.getStatus();\n        \n        return {\n          success: true,\n          data: {\n            ...status,\n            capabilities: seoAgent.getCapabilities(),\n            isAIEnabled: Boolean(process.env.OPENAI_API_KEY)\n          }\n        };\n      } catch (error) {\n        logger.error('Failed to get SEO agent status', { error }, 'SEORouter');\n        throw error;\n      }\n    }),\n}); ","usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/simple-test.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/social.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/support.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/trends.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":25,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":66,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":66,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":89,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":147,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":147,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":195,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":195,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":246,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":246,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8034,8037],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8034,8037],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":281,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8407,8410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8407,8410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":305,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9170,9173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9170,9173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Trends Router - Market Pulse Integration\n * Handles social media trend analysis and regional scoring\n */\n\nimport { z } from 'zod';\nimport { createTRPCRouter, publicProcedure } from '../trpc';\nimport { SocialApiClient } from '@neon/utils/social-api-client';\n\nconst socialApiClient = new SocialApiClient();\n\nexport const trendsRouter = createTRPCRouter({\n  // Get all trending data across platforms\n  getAllTrends: publicProcedure\n    .query(async () => {\n      try {\n        const trends = await socialApiClient.getAllTrends();\n        \n        return {\n          success: true,\n          data: trends,\n          count: trends.length,\n          lastUpdated: new Date().toISOString(),\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: [],\n          error: 'Failed to fetch trends',\n        };\n      }\n    }),\n\n  // Get trends by platform\n  getTrendsByPlatform: publicProcedure\n    .input(z.object({\n      platform: z.enum(['tiktok', 'instagram', 'twitter']),\n      limit: z.number().min(1).max(100).default(20),\n    }))\n    .query(async ({ input }) => {\n      try {\n        let trends;\n        \n        switch (input.platform) {\n          case 'tiktok':\n            trends = await socialApiClient.fetchTrendingTikTok();\n            break;\n          case 'instagram':\n            trends = await socialApiClient.fetchTrendingInstagram();\n            break;\n          case 'twitter':\n            trends = await socialApiClient.fetchTrendingTwitter();\n            break;\n          default:\n            trends = [];\n        }\n        \n        const limitedTrends = trends.slice(0, input.limit);\n        \n        return {\n          success: true,\n          data: limitedTrends,\n          platform: input.platform,\n          count: limitedTrends.length,\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: [],\n          error: `Failed to fetch ${input.platform} trends`,\n        };\n      }\n    }),\n\n  // Get regional trend scores\n  getRegionalScores: publicProcedure\n    .input(z.object({\n      region: z.string(),\n    }))\n    .query(async ({ input }) => {\n      try {\n        const regionScores = await socialApiClient.getRegionScores(input.region);\n        \n        return {\n          success: true,\n          data: regionScores,\n          region: input.region,\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: null,\n          error: 'Failed to fetch regional scores',\n        };\n      }\n    }),\n\n  // Analyze trend predictions\n  analyzeTrendPredictions: publicProcedure\n    .input(z.object({\n      keywords: z.array(z.string()).min(1).max(10),\n      timeframe: z.enum(['24h', '7d', '30d']).default('7d'),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        const allTrends = await socialApiClient.getAllTrends();\n        \n        // Filter trends by keywords\n        const relevantTrends = allTrends.filter(trend =>\n          input.keywords.some(keyword =>\n            trend.keyword.toLowerCase().includes(keyword.toLowerCase())\n          )\n        );\n        \n        // Calculate predictions based on score trends\n        const predictions = input.keywords.map(keyword => {\n          const keywordTrends = relevantTrends.filter(trend =>\n            trend.keyword.toLowerCase().includes(keyword.toLowerCase())\n          );\n          \n          const avgScore = keywordTrends.length > 0\n            ? keywordTrends.reduce((sum, trend) => sum + trend.score, 0) / keywordTrends.length\n            : 0;\n          \n          // Simple prediction model - in production use ML algorithms\n          const prediction = avgScore > 0.7 ? 'rising' : avgScore > 0.4 ? 'stable' : 'declining';\n          const confidence = Math.min(avgScore * 100, 95);\n          \n          return {\n            keyword,\n            prediction,\n            confidence,\n            avgScore,\n            platforms: keywordTrends.map(t => t.platform),\n            recommendation: getRecommendation(prediction, avgScore),\n          };\n        });\n        \n        return {\n          success: true,\n          data: {\n            predictions,\n            timeframe: input.timeframe,\n            analyzedAt: new Date().toISOString(),\n          },\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: null,\n          error: 'Failed to analyze trend predictions',\n        };\n      }\n    }),\n\n  // Get trend insights for content strategy\n  getTrendInsights: publicProcedure\n    .input(z.object({\n      industry: z.string().optional(),\n      contentType: z.enum(['video', 'image', 'text', 'story']).optional(),\n    }))\n    .query(async ({ input }) => {\n      try {\n        const allTrends = await socialApiClient.getAllTrends();\n        \n        // Filter by industry if provided\n        let filteredTrends = allTrends;\n        if (input.industry) {\n          filteredTrends = allTrends.filter(trend =>\n            trend.keyword.toLowerCase().includes(input.industry.toLowerCase()) ||\n            trend.metadata?.industry === input.industry\n          );\n        }\n        \n        // Sort by score and get top trends\n        const topTrends = filteredTrends\n          .sort((a, b) => b.score - a.score)\n          .slice(0, 10);\n        \n        // Generate insights\n        const insights = {\n          topKeywords: topTrends.map(t => t.keyword),\n          bestPlatforms: getBestPlatforms(topTrends),\n          contentRecommendations: getContentRecommendations(topTrends, input.contentType),\n          optimalTiming: getOptimalTiming(),\n          expectedReach: calculateExpectedReach(topTrends),\n        };\n        \n        return {\n          success: true,\n          data: insights,\n          industry: input.industry,\n          contentType: input.contentType,\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: null,\n          error: 'Failed to generate trend insights',\n        };\n      }\n    }),\n\n  // Monitor specific trend keywords\n  monitorKeywords: publicProcedure\n    .input(z.object({\n      keywords: z.array(z.string()).min(1).max(20),\n      alertThreshold: z.number().min(0).max(1).default(0.8),\n    }))\n    .mutation(async ({ input }) => {\n      try {\n        const allTrends = await socialApiClient.getAllTrends();\n        \n        const monitoredTrends = input.keywords.map(keyword => {\n          const relevantTrends = allTrends.filter(trend =>\n            trend.keyword.toLowerCase().includes(keyword.toLowerCase())\n          );\n          \n          const maxScore = relevantTrends.length > 0\n            ? Math.max(...relevantTrends.map(t => t.score))\n            : 0;\n          \n          const shouldAlert = maxScore >= input.alertThreshold;\n          \n          return {\n            keyword,\n            currentScore: maxScore,\n            shouldAlert,\n            trendingPlatforms: relevantTrends\n              .filter(t => t.score >= input.alertThreshold)\n              .map(t => t.platform),\n            lastUpdated: new Date().toISOString(),\n          };\n        });\n        \n        const alerts = monitoredTrends.filter(t => t.shouldAlert);\n        \n        return {\n          success: true,\n          data: {\n            monitoredTrends,\n            alerts,\n            alertCount: alerts.length,\n          },\n        };\n      } catch (_error) {\n        return {\n          success: false,\n          data: null,\n          error: 'Failed to monitor keywords',\n        };\n      }\n    }),\n});\n\n// Helper methods (would be class methods in production)\nfunction getRecommendation(prediction: string, score: number): string {\n  if (prediction === 'rising' && score > 0.8) {\n    return 'Create content immediately - high viral potential';\n  } else if (prediction === 'rising') {\n    return 'Good opportunity for content creation';\n  } else if (prediction === 'stable') {\n    return 'Safe choice for consistent engagement';\n  } else {\n    return 'Consider alternative keywords';\n  }\n}\n\nfunction getBestPlatforms(trends: any[]): string[] {\n  const platformCounts = trends.reduce((acc, trend) => {\n    acc[trend.platform] = (acc[trend.platform] || 0) + trend.score;\n    return acc;\n  }, {} as Record<string, number>);\n  \n  return Object.entries(platformCounts)\n    .sort(([, a], [, b]) => b - a)\n    .slice(0, 3)\n    .map(([platform]) => platform);\n}\n\nfunction getContentRecommendations(trends: any[], contentType?: string): string[] {\n  const recommendations = [\n    'Use trending hashtags in your content',\n    'Create content around peak engagement times',\n    'Incorporate current trending topics',\n  ];\n  \n  if (contentType === 'video') {\n    recommendations.push('Focus on short-form video content', 'Use trending audio tracks');\n  } else if (contentType === 'image') {\n    recommendations.push('Use bold, eye-catching visuals', 'Include trending colors');\n  }\n  \n  return recommendations;\n}\n\nfunction getOptimalTiming(): string[] {\n  return [\n    'Post between 6-9 PM for maximum engagement',\n    'Tuesday through Thursday show highest activity',\n    'Weekend posts perform well for lifestyle content',\n  ];\n}\n\nfunction calculateExpectedReach(trends: any[]): number {\n  const avgScore = trends.reduce((sum, trend) => sum + trend.score, 0) / trends.length;\n  return Math.floor(avgScore * 100000); // Mock calculation\n} ","usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/user.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/routers/user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/trpc.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/server/trpc.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/trpc/context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/apps/api/src/trpc/trpc.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
