[{"filePath":"/workspace/packages/reasoning-engine/src/index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/workspace/packages/reasoning-engine/src/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[264,267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[264,267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[511,514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[511,514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[602,605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[602,605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[855,858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[855,858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1089,1092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1089,1092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":176,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":176,"endColumn":13},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":443,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":443,"endColumn":13}],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":34,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":107,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":107,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2694,2737],"text":""},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":136,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":136,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[3522,3565],"text":""},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from 'events';\nimport Redis from 'redis';\n\n// Types for reasoning engine\nexport interface ReasoningContext {\n  id: string;\n  sessionId: string;\n  userId?: string;\n  campaignId?: string;\n  history: ContextEntry[];\n  metadata: Record<string, any>;\n  createdAt: Date;\n  lastAccessed: Date;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n}\n\nexport interface ContextEntry {\n  id: string;\n  type: 'user_input' | 'agent_output' | 'system_message' | 'tool_call' | 'tool_result';\n  content: any;\n  agentId?: string;\n  timestamp: Date;\n  tokens?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface InferenceRequest {\n  contextId: string;\n  prompt: string;\n  agentType?: string;\n  temperature?: number;\n  maxTokens?: number;\n  stream?: boolean;\n  priority?: 'low' | 'medium' | 'high' | 'critical';\n  metadata?: Record<string, any>;\n}\n\nexport interface InferenceResult {\n  id: string;\n  contextId: string;\n  content: string;\n  agentId?: string;\n  tokensUsed: number;\n  responseTime: number;\n  cached: boolean;\n  confidence?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface AgentRoute {\n  agentType: string;\n  priority: number;\n  capabilities: string[];\n  load: number;\n  avgResponseTime: number;\n  successRate: number;\n}\n\n// Context cache with intelligent eviction\nexport class ContextCache {\n  private cache = new Map<string, ReasoningContext>();\n  private accessOrder = new Map<string, number>();\n  private maxSize: number;\n  private redis?: Redis.RedisClientType;\n  private metrics = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    totalTokens: 0\n  };\n\n  constructor(maxSize: number = 1000, redisUrl?: string) {\n    this.maxSize = maxSize;\n    \n    if (redisUrl) {\n      this.redis = Redis.createClient({ url: redisUrl });\n      // eslint-disable-next-line no-console\n      this.redis.connect().catch(console.error);\n    }\n  }\n\n  async get(contextId: string): Promise<ReasoningContext | null> {\n    // Check memory cache first\n    const memoryContext = this.cache.get(contextId);\n    if (memoryContext) {\n      this.accessOrder.set(contextId, Date.now());\n      memoryContext.lastAccessed = new Date();\n      this.metrics.hits++;\n      return memoryContext;\n    }\n\n    // Check Redis cache\n    if (this.redis) {\n      try {\n        const cached = await this.redis.get(`context:${contextId}`);\n        if (cached) {\n          const context: ReasoningContext = JSON.parse(cached);\n          context.lastAccessed = new Date();\n          \n          // Store in memory cache\n          this.set(context);\n          this.metrics.hits++;\n          return context;\n        }\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error('Redis cache error:', error);\n      }\n    }\n\n    this.metrics.misses++;\n    return null;\n  }\n\n  async set(context: ReasoningContext): Promise<void> {\n    // Evict if at capacity\n    if (this.cache.size >= this.maxSize) {\n      await this.evictLRU();\n    }\n\n    // Update memory cache\n    this.cache.set(context.id, context);\n    this.accessOrder.set(context.id, Date.now());\n\n    // Update token count\n    const tokens = context.history.reduce((sum, entry) => sum + (entry.tokens || 0), 0);\n    this.metrics.totalTokens += tokens;\n\n    // Store in Redis with TTL\n    if (this.redis) {\n      try {\n        const ttl = this.getTTL(context.priority);\n        await this.redis.setEx(`context:${context.id}`, ttl, JSON.stringify(context));\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error('Redis cache error:', error);\n      }\n    }\n  }\n\n  private async evictLRU(): Promise<void> {\n    if (this.accessOrder.size === 0) return;\n\n    let oldestTime = Date.now();\n    let oldestKey = '';\n\n    for (const [key, time] of this.accessOrder.entries()) {\n      if (time < oldestTime) {\n        oldestTime = time;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey);\n      this.accessOrder.delete(oldestKey);\n      this.metrics.evictions++;\n      \n      // Remove from Redis\n      if (this.redis) {\n        await this.redis.del(`context:${oldestKey}`);\n      }\n    }\n  }\n\n  private getTTL(priority: string): number {\n    switch (priority) {\n      case 'critical': return 7200; // 2 hours\n      case 'high': return 3600; // 1 hour\n      case 'medium': return 1800; // 30 minutes\n      case 'low': return 900; // 15 minutes\n      default: return 1800;\n    }\n  }\n\n  getMetrics() {\n    return {\n      ...this.metrics,\n      hitRate: this.metrics.hits / (this.metrics.hits + this.metrics.misses),\n      cacheSize: this.cache.size,\n      avgTokensPerContext: this.metrics.totalTokens / Math.max(this.cache.size, 1)\n    };\n  }\n}\n\n// Intelligent agent router\nexport class AgentRouter {\n  private routes = new Map<string, AgentRoute>();\n  private loadBalancer = new Map<string, number>();\n\n  registerAgent(agentType: string, capabilities: string[]): void {\n    this.routes.set(agentType, {\n      agentType,\n      priority: 1,\n      capabilities,\n      load: 0,\n      avgResponseTime: 0,\n      successRate: 1.0\n    });\n    this.loadBalancer.set(agentType, 0);\n  }\n\n  findBestAgent(task: string, context: ReasoningContext): string | null {\n    const candidates: Array<{ agentType: string; score: number }> = [];\n\n    for (const [agentType, route] of this.routes.entries()) {\n      if (route.capabilities.includes(task)) {\n        const score = this.calculateAgentScore(route, context);\n        candidates.push({ agentType, score });\n      }\n    }\n\n    if (candidates.length === 0) {\n      return null;\n    }\n\n    // Sort by score (higher is better)\n    candidates.sort((a, b) => b.score - a.score);\n    \n    // Update load balancing\n    const bestCandidate = candidates[0];\n    if (!bestCandidate) return null;\n    \n    const bestAgent = bestCandidate.agentType;\n    this.loadBalancer.set(bestAgent, (this.loadBalancer.get(bestAgent) || 0) + 1);\n    \n    return bestAgent;\n  }\n\n  private calculateAgentScore(route: AgentRoute, context: ReasoningContext): number {\n    let score = route.successRate * 100; // Base score from success rate\n    \n    // Penalty for high load\n    score -= route.load * 10;\n    \n    // Bonus for fast response times\n    score += Math.max(0, (1000 - route.avgResponseTime) / 100);\n    \n    // Priority boost for high-priority contexts\n    if (context.priority === 'critical') score += 50;\n    else if (context.priority === 'high') score += 25;\n    \n    return Math.max(0, score);\n  }\n\n  updateAgentMetrics(agentType: string, responseTime: number, success: boolean): void {\n    const route = this.routes.get(agentType);\n    if (!route) return;\n\n    // Update average response time (exponential moving average)\n    route.avgResponseTime = route.avgResponseTime * 0.8 + responseTime * 0.2;\n    \n    // Update success rate (exponential moving average)\n    route.successRate = route.successRate * 0.9 + (success ? 1 : 0) * 0.1;\n    \n    // Decrease load\n    route.load = Math.max(0, route.load - 1);\n    this.loadBalancer.set(agentType, Math.max(0, (this.loadBalancer.get(agentType) || 0) - 1));\n  }\n\n  getRouteStats(): Array<AgentRoute> {\n    return Array.from(this.routes.values());\n  }\n}\n\n// Main reasoning engine with streaming and caching\nexport class ReasoningEngine extends EventEmitter {\n  private contextCache: ContextCache;\n  private agentRouter: AgentRouter;\n  private activeInferences = new Map<string, InferenceRequest>();\n  private metrics = {\n    totalInferences: 0,\n    avgResponseTime: 0,\n    streamingRequests: 0,\n    cachedResponses: 0\n  };\n\n  constructor(options: { \n    maxCacheSize?: number; \n    redisUrl?: string;\n  } = {}) {\n    super();\n    this.contextCache = new ContextCache(options.maxCacheSize, options.redisUrl);\n    this.agentRouter = new AgentRouter();\n  }\n\n  async createContext(sessionId: string, userId?: string, campaignId?: string): Promise<ReasoningContext> {\n    const context: ReasoningContext = {\n      id: `ctx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      sessionId,\n      ...(userId && { userId }),\n      ...(campaignId && { campaignId }),\n      history: [],\n      metadata: {},\n      createdAt: new Date(),\n      lastAccessed: new Date(),\n      priority: 'medium'\n    };\n\n    await this.contextCache.set(context);\n    return context;\n  }\n\n  async addToContext(contextId: string, entry: Omit<ContextEntry, 'id' | 'timestamp'>): Promise<void> {\n    const context = await this.contextCache.get(contextId);\n    if (!context) {\n      throw new Error(`Context not found: ${contextId}`);\n    }\n\n    const contextEntry: ContextEntry = {\n      ...entry,\n      id: `entry_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: new Date()\n    };\n\n    context.history.push(contextEntry);\n    context.lastAccessed = new Date();\n    \n    // Limit context window size (keep last 50 entries)\n    if (context.history.length > 50) {\n      context.history = context.history.slice(-50);\n    }\n\n    await this.contextCache.set(context);\n  }\n\n  async processInference(request: InferenceRequest): Promise<InferenceResult | AsyncIterable<string>> {\n    const startTime = Date.now();\n    const inferenceId = `inf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    this.activeInferences.set(inferenceId, request);\n    this.metrics.totalInferences++;\n\n    try {\n      const context = await this.contextCache.get(request.contextId);\n      if (!context) {\n        throw new Error(`Context not found: ${request.contextId}`);\n      }\n\n      // Check for cached response\n      const cacheKey = this.generateCacheKey(request, context);\n      const cachedResult = await this.getCachedResponse(cacheKey);\n      \n      if (cachedResult) {\n        this.metrics.cachedResponses++;\n        return cachedResult;\n      }\n\n      // Find best agent for the task\n      const bestAgent = this.agentRouter.findBestAgent(request.agentType || 'general', context);\n      \n      if (request.stream) {\n        this.metrics.streamingRequests++;\n        return this.processStreamingInference(request, context, bestAgent);\n      } else {\n        return await this.processBatchInference(request, context, bestAgent);\n      }\n\n    } finally {\n      this.activeInferences.delete(inferenceId);\n      const responseTime = Date.now() - startTime;\n      this.metrics.avgResponseTime = this.metrics.avgResponseTime * 0.9 + responseTime * 0.1;\n    }\n  }\n\n  private async processBatchInference(\n    request: InferenceRequest, \n    _context: ReasoningContext, \n    agentId: string | null\n  ): Promise<InferenceResult> {\n    const startTime = Date.now();\n\n    // Mock inference - in production this would call actual AI models\n    // Add realistic delay for testing\n    await new Promise(resolve => setTimeout(resolve, 10));\n    const mockResponse = `AI response for: ${request.prompt.substring(0, 50)}...`;\n    const responseTime = Date.now() - startTime;\n\n    const result: InferenceResult = {\n      id: `result_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      contextId: request.contextId,\n      content: mockResponse,\n      ...(agentId && { agentId }),\n      tokensUsed: Math.floor(mockResponse.length / 4), // Rough token estimate\n      responseTime,\n      cached: false,\n      confidence: 0.95\n    };\n\n    // Update agent metrics\n    if (agentId) {\n      this.agentRouter.updateAgentMetrics(agentId, responseTime, true);\n    }\n\n    // Add to context\n    await this.addToContext(request.contextId, {\n      type: 'agent_output',\n      content: result.content,\n      ...(agentId && { agentId }),\n      tokens: result.tokensUsed\n    });\n\n    return result;\n  }\n\n  private async *processStreamingInference(\n    request: InferenceRequest, \n    _context: ReasoningContext, \n    agentId: string | null\n  ): AsyncIterable<string> {\n    // Mock streaming response - in production this would stream from AI models\n    const fullResponse = `Streaming AI response for: ${request.prompt}`;\n    const words = fullResponse.split(' ');\n\n    for (const word of words) {\n      yield `${word  } `;\n      await new Promise(resolve => setTimeout(resolve, 50)); // Simulate streaming delay\n    }\n\n    // Update context with full response\n    await this.addToContext(request.contextId, {\n      type: 'agent_output',\n      content: fullResponse,\n      ...(agentId && { agentId }),\n      tokens: Math.floor(fullResponse.length / 4)\n    });\n  }\n\n  private generateCacheKey(request: InferenceRequest, context: ReasoningContext): string {\n    const contextHash = context.history.slice(-5).map(h => h.content).join('|');\n    return `cache:${request.prompt}:${contextHash}:${request.agentType}`;\n  }\n\n  private async getCachedResponse(_cacheKey: string): Promise<InferenceResult | null> {\n    // Simple in-memory cache for now - in production use Redis with proper TTL\n    return null;\n  }\n\n  registerAgentType(agentType: string, capabilities: string[]): void {\n    this.agentRouter.registerAgent(agentType, capabilities);\n  }\n\n  getMetrics() {\n    return {\n      ...this.metrics,\n      cache: this.contextCache.getMetrics(),\n      agents: this.agentRouter.getRouteStats(),\n      activeInferences: this.activeInferences.size\n    };\n  }\n\n  async cleanup(): Promise<void> {\n    this.removeAllListeners();\n    // Additional cleanup if needed\n  }\n}\n\n// Main interfaces and classes are exported inline above","usedDeprecatedRules":[]}]
